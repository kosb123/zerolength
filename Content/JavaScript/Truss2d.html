<HTML>
<HEAD>
<TITLE>Two Dimensional Truss</TITLE>
<SCRIPT LANGUAGE = JavaScript>
//-----   Program Truss2d    -----
//    Chandrupatla & Belegundu
//------------------------------
var Dummy, Dummy1, title
var nn,ne,nm,ndim,nen,ndn,nd,nl,nmpc,cnst,nbw,nq,npr=2
var x = new Array()
var noc = new Array()
var f = new Array()
var area = new Array()
var mat = new Array()
var dt = new Array()
var pm = new Array()
var nu = new Array()
var u = new Array()
var mpc = new Array()
var bt = new Array()
var s = new Array()
var stress = new Array()
var react = new Array()
var se = new Array()
var tl = new Array()
var stiff = new Array()

function Truss2d(){
InputData()
Bandwidth()
Stiffness()
ModifyForBC()
BandSolver()
StressCalc()
ReactionCalc()
Output()
}//Truss2d

function InputData(){
Dummy = document.form.input.value
/* ---  Read NN,NE,... --- */
Dummy = lineRemoved(Dummy)
title = nxtLine(Dummy)
Dummy = lineRemoved(Dummy)
Dummy = lineRemoved(Dummy)
Dummy1 = nxtLine(Dummy)
Dummy = lineRemoved(Dummy)
nn = parseInt(token(Dummy1))
Dummy1 = tknRemoved(Dummy1)
ne = parseInt(token(Dummy1))
Dummy1 = tknRemoved(Dummy1)
nm = parseInt(token(Dummy1))
Dummy1 = tknRemoved(Dummy1)
ndim = parseInt(token(Dummy1))
Dummy1 = tknRemoved(Dummy1)
nen = parseInt(token(Dummy1))
Dummy1 = tknRemoved(Dummy1)
ndn = parseInt(Dummy1)
nq = nn*ndn
for(i = 0; i < nq; i++){
  f[i] = 0
  }
/* ---  Read ND,NL,... --- */
Dummy = lineRemoved(Dummy)
Dummy1 = nxtLine(Dummy)
Dummy = lineRemoved(Dummy)
nd = parseInt(token(Dummy1))
Dummy1 = tknRemoved(Dummy1)
nl = parseInt(token(Dummy1))
Dummy1 = tknRemoved(Dummy1)
nmpc = parseInt(Dummy1)
/* ---  Read coordinates --- */
Dummy = lineRemoved(Dummy)
for(i = 0; i < nn; i++){
   Dummy1 = nxtLine(Dummy)
   Dummy = lineRemoved(Dummy)
   n = parseInt(token(Dummy1)) - 1
   x[n] = new Array(ndim)
   Dummy1=tknRemoved(Dummy1)
   x[n][0] = parseFloat(token(Dummy1))
   Dummy1=tknRemoved(Dummy1)
   x[n][1] = parseFloat(Dummy1)
}
/* ---  Read connectivity etc --- */
Dummy = lineRemoved(Dummy)
for(i = 0; i < ne; i++){
   Dummy1 = nxtLine(Dummy)
   Dummy = lineRemoved(Dummy)
   n = parseInt(token(Dummy1)) - 1
   Dummy1=tknRemoved(Dummy1)
   noc[n] = new Array(nen)
   for(j = 0; j < nen; j++){
   noc[n][j] = parseInt(token(Dummy1))
   Dummy1 = tknRemoved(Dummy1)
   }
   mat[n] = parseInt(token(Dummy1))
   Dummy1 = tknRemoved(Dummy1)
   area[n] = parseFloat(token(Dummy1))
   Dummy1=tknRemoved(Dummy1)
   dt[n] = parseFloat(Dummy1)
}
/* ---  Read Specified Displacements --- */
Dummy = lineRemoved(Dummy)
for(i = 0; i < nd; i++){
   Dummy1 = nxtLine(Dummy)
   Dummy = lineRemoved(Dummy)
   nu[i] = parseInt(token(Dummy1))
   Dummy1=tknRemoved(Dummy1)
   u[i] = parseFloat(Dummy1)
}
/* ---  Read Component Loads --- */
Dummy = lineRemoved(Dummy)
for(i = 0; i < nl; i++){
   Dummy1 = nxtLine(Dummy)
   Dummy = lineRemoved(Dummy)
   n = parseInt(token(Dummy1)) - 1
   Dummy1=tknRemoved(Dummy1)
   f[n] = parseFloat(Dummy1)
}
/* ---  Read Material Properties --- */
Dummy = lineRemoved(Dummy)
for(i = 0; i < nm; i++){
   Dummy1 = nxtLine(Dummy)
   Dummy = lineRemoved(Dummy)
   n = parseInt(token(Dummy1)) - 1
   pm[n] = new Array(npr)
   Dummy1=tknRemoved(Dummy1)
   pm[n][0] = parseFloat(token(Dummy1))
   Dummy1=tknRemoved(Dummy1)
   pm[n][1] = parseFloat(Dummy1)
}
/* ---  Read Multi-point Constraints --- */
Dummy = lineRemoved(Dummy)
for(i = 0; i < nmpc; i++){
   bt[i] = new Array(3)
   mpc[i] = new Array(2)
   Dummy1 = nxtLine(Dummy)
   Dummy = lineRemoved(Dummy)
   bt[i][0] = parseFloat(token(Dummy1))
   Dummy1=tknRemoved(Dummy1)
   mpc[i][0] = parseInt(token(Dummy1))
   Dummy1=tknRemoved(Dummy1)
   bt[i][1] = parseFloat(token(Dummy1))
   Dummy1=tknRemoved(Dummy1)
   mpc[i][1] = parseInt(token(Dummy1))
   Dummy1=tknRemoved(Dummy1)
   bt[i][2] = parseFloat(Dummy1)
}
}//InputData

function Bandwidth() {
     /* ----- Bandwidth Evaluation ----- */
     nbw = 0
     for (n = 0; n < ne; n++){
        nabs = ndn*(Math.abs(noc[n][0] - noc[n][1]) + 1)
        if (nbw < nabs){nbw = nabs}
     }
     for (i = 0; i < nmpc; i++){     
        nabs = Math.abs(mpc[i][0] - mpc[i][1]) + 1
        if (nbw < nabs){nbw = nabs}
     }
}//Bandwidth

function Stiffness() {
/* ----- assemble the stiffness matrix ----- */
  /* --- Initialization of Matrices ---*/
   for (i = 0; i < nq; i++){
       stiff[i] = new Array(nbw)
       for (j = 0; j < nbw; j++){
          stiff[i][j] = 0
       }
   }
   for (i = 0; i < 4; i++){
      se[i] = new Array(4)
   }
  /* --- Loop on Elements --- */
   for (n = 0; n < ne; n++) {
        ElemStiff(n)
      /* --- Placing in Global Locations --- */
	for (ii = 0; ii < nen; ii++) {
	   nrt = ndn * (noc[n][ii] - 1)
	   for (it = 0; it < ndn; it++) {
	      nr = nrt + it
	      i = ndn * ii + it
	      for (jj = 0; jj < nen; jj++) {
		 nct = ndn * (noc[n][jj] - 1)
		 for (jt = 0; jt < ndn; jt++) {
		    j = ndn * jj + jt
		    nc = nct + jt - nr
		    if (nc >= 0)
		       stiff[nr][nc] = stiff[nr][nc] + se[i][j]
		    }
		 }
	      f[nr] = f[nr] + tl[i]
	      }
	   }
   }
}//Stiffness

function ElemStiff(n) {
/* ----- connectivity and coordinate data ----- */
        i1 = noc[n][0]
        i2 = noc[n][1]
        i3 = mat[n]
        x21 = x[i2-1][0] - x[i1-1][0]
        y21 = x[i2-1][1] - x[i1-1][1]
        el = Math.sqrt(x21 * x21 + y21 * y21)
        eal = pm[i3-1][0] * area[n] / el
        cs = x21 / el
        sn = y21 / el
     /*----- element stiffness matrix se() -----*/
        se[0][0] = cs * cs * eal
        se[0][1] = cs * sn * eal
        se[0][2] = -cs * cs * eal
        se[0][3] = -cs * sn * eal
          se[1][0] = se[0][1]
          se[1][1] = sn * sn * eal
          se[1][2] = -cs * sn * eal
          se[1][3] = -sn * sn * eal
        se[2][0] = se[0][2]
        se[2][1] = se[1][2]
        se[2][2] = cs * cs * eal
        se[2][3] = cs * sn * eal
          se[3][0] = se[0][3]
          se[3][1] = se[1][3]
          se[3][2] = se[2][3]
          se[3][3] = sn * sn * eal
     /*----- temperature load tl() -----*/
        ee0 = pm[i3-1][1] * dt[n] * pm[i3-1][0] * area[n]
        tl[0] = -ee0 * cs
        tl[1] = -ee0 * sn
        tl[2] = ee0 * cs
        tl[3] = ee0 * sn
}//ElemStiff

function ModifyForBC(){
/* ----- decide penalty parameter cnst ----- */
   cnst = 0
   for (i = 0;i < nq; i++){
       if (cnst < stiff[i][0]){cnst = stiff[i][0]}
       }
   cnst = 10000 * cnst
/* ----- modify for displacement boundary conditions ----- */
   for (i = 0; i < nd; i++) {
      k = nu[i]
      stiff[k-1][0] = stiff[k-1][0] + cnst
      f[k-1] = f[k-1] + cnst * u[i]
   }
/* ----- modify for multipoint constraints ----- */
   for (i = 0; i < nmpc; i++){
       i1 = mpc[i][0]
       i2 = mpc[i][1]
       stiff[i1-1][0] = stiff[i1-1][0] + cnst*bt[i][0]*bt[i][0]
       stiff[i2-1][0] = stiff[i2-1][0] + cnst*bt[i][1]*bt[i][1]
       n=i1
       if (n > i2){n = i2}
       m = Math.abs(i2-i1)
       stiff[n-1][m] = stiff[n-1][m]+cnst*bt[i][0]*bt[i][1]
       f[i1-1] = f[i1-1] + cnst*bt[i][0]*bt[i][2]
       f[i2-1] = f[i2-1] + cnst*bt[i][1]*bt[i][2]
       }
}//ModifyForBC


function BandSolver(){
  /* ----- band solver ----- */
  n1 = nq - 1
  /* --- forward elimination --- */
  for (k = 1; k <= n1; k++) {
     nk = nq - k + 1
     if (nk > nbw) {nk = nbw}
     for (i = 2; i <= nk; i++) {
       c1 = stiff[k-1][i-1] / stiff[k-1][0]
       i1 = k + i - 1
       for (j = i; j <= nk; j++) {
	j1 = j - i + 1;
	stiff[i1-1][j1-1] = stiff[i1-1][j1-1] - c1 * stiff[k-1][j-1]
	}
       f[i1-1] = f[i1-1] - c1 * f[k-1]
       }
     }
  /* --- back-substitution --- */
  f[nq-1] = f[nq-1] / stiff[nq-1][0]
  for (kk = 1; kk <= n1;kk++) {
     k = nq - kk
     c1 = 1 / stiff[k-1][0]
     f[k-1] = c1 * f[k-1]
     nk = nq - k + 1
     if (nk > nbw){nk = nbw}
       for (j = 2; j <= nk; j++) {
	 f[k-1] = f[k-1] - c1 * stiff[k-1][j-1] * f[k + j - 2]
	}
     }
}//BandSolver

function StressCalc(){
     /*----- Stress Calculation ----- */
     for (i = 0; i < ne; i++){
        i1 = noc[i][0]
        i2 = noc[i][1]
        i3 = mat[i]
        x21 = x[i2-1][0] - x[i1-1][0]
        y21 = x[i2-1][1] - x[i1-1][1]
        el = Math.sqrt(x21 * x21 + y21 * y21)
        cs = x21 / el
        sn = y21 / el
        j2 = 2 * i1 - 1
        j1 = j2 - 1
        k2 = 2 * i2 - 1
        k1 = k2 - 1
        dlt = (f[k1] - f[j1]) * cs + (f[k2] - f[j2]) * sn
        stress[i] = pm[i3-1][0] * (dlt / el - pm[i3-1][1] * dt[i])
     }
}//StressCalc()

function ReactionCalc(){
     /* ----- Reaction Calculation ----- */
     for (i = 0; i < nd; i++){
        n = nu[i]
        react[i] = cnst * (u[i] - f[n-1])
     }
}//ReactionCalc()

function Output(){
Dummy = title+'\n'
Dummy=Dummy +'Node# X-Displ.  Y-Displ.' +'\n'
for (i = 0; i < nn; i++){
  ii = i + 1
  Dummy = Dummy +'  '+ ii + '   ' + f[2*i].toExponential(4)+ '   ' + f[2*i+1].toExponential(4) + '\n'
}
Dummy=Dummy +'Elem# Stress' +'\n'
for (i = 0; i < ne; i++){
  ii = i + 1
  Dummy = Dummy  +'  '+ ii + '   ' + stress[i].toExponential(4) + '\n'
}
Dummy=Dummy +'DOF#  ReactionForce' +'\n'
for (i = 0; i < nd; i++){
  Dummy = Dummy +'  ' + nu[i] + '   ' + react[i].toExponential(4) + '\n'
}
document.form.output.value = Dummy
}//Output

function nxtLine(str){
ii = str.indexOf('\n')
return ltrim(str.substring(0,ii))
}//nxtLine()

function lineRemoved(str){
ii = str.indexOf('\n')
return ltrim(str.substring(ii+1))
}//removed()

function token(str){
ii = str.indexOf(' ')
return str.substring(0,ii)
}

function tknRemoved(str){
ii = str.indexOf(' ')
return ltrim(str.substring(ii+1))
}

function ltrim(str) 
{ 
    return str.replace(/^[ ]+/, ''); 
}//ltrim()




</SCRIPT>
</HEAD>

<BODY BGCOLOR = LightSalmon>
<H2>Finite Element Analysis - 2D TRUSS Problems</H2>
Edit input or cut and paste from a text editor then click SOLVE.
<FORM NAME = form onSubmit = "Truss2d(); return false">
<TEXTAREA NAME=input ROWS=13 COLS=84>
Next line is problem title      << 2D TRUSS ANALYSIS >>
EXAMPLE 4.1
NN NE NM NDIM NEN NDN
 4  4  1  2    2   2
ND NL  NMPC
 5  2   0
Node#  X   Y
 1     0   0
 2    40   0
 3    40  30
 4     0  30
Elem#  N1  N2  Mat#  Area  TempRise 
 1      1   2   1     1     0
 2      3   2   1     1     0
 3      3   1   1     1     0
 4      4   3   1     1     0
DOF#  Displacement
 1     0
 2     0
 4     0
 7     0
 8     0
DOF#  Load
 3     20000
 6    -25000
MAT#   E      Alpha
 1    29.5E6  12E-6
B1  i  B2 j  B3  (Multi-point constr. B1*Qi+B2*Qj=B3)
</TEXTAREA><BR>
<INPUT TYPE = submit value = 'SOLVE'><BR>
<TEXTAREA NAME=output ROWS=13 COLS=84></TEXTAREA><BR>
</FORM>
<div style="display: block; font-family: Verdana, Geneva, Arial; font-size: 12px">
<pre>All care has been taken in preparing the program. The authors or the publishers shall not be
liable for incidental or conseqential damages arising out of the use of the program.

(c) T.R.Chandrupatla & A.D.Belegundu</pre>
</BODY>
</HTML>
