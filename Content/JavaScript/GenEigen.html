<HTML>
<HEAD>
<TITLE>Inverse Interation for Eigenvalues</TITLE>
<SCRIPT LANGUAGE = JavaScript>
//***************************************
//*          PROGRAM DENEIGEN           *
//*   Generalized Eigenvalue Problem    *
//*           Kx = lambda Mx            *
//*  T.R.Chandrupatla and A.D.Belegundu *
//***************************************
var Dummy, Dummy1, title
var Dummy2 = ''
var nq, cab, nsw, nswmax
var tol, iter

var s = new Array()
var gm = new Array()
var d = new Array()
var b = new Array()
var nord = new Array()

function GenEigen(){
   InputData()
   Cholesky(nq)
   UpdateStiff(nq)
   TriDiag(nq)
   EigenTD(nq)
   EigenVec(nq)
   AscendEigen(nq)
   Output()
}//GenEigen

function InputData(){
   Dummy = prompt ("Tolerance enter value (suggested 0.00001) ","")
   tol = parseFloat(Dummy)
   Dummy = document.form.input.value
   //Read title,nq,nbw
   Dummy = lineRemoved(Dummy)
   title = nxtLine(Dummy)
   Dummy = lineRemoved(Dummy)
   Dummy = lineRemoved(Dummy)
   Dummy1 = nxtLine(Dummy)
   Dummy = lineRemoved(Dummy)
   nq = parseInt(token(Dummy1))
   Dummy1 = tknRemoved(Dummy1)
   nbw = parseInt(Dummy1)
   //Initialization of Stiffness and Mass Matrices
   for (i = 0; i < nq; i++) {
      s[i] = new Array(nq)
      gm[i] = new Array(nq)
      for (j = 0; j < nq; j++) {
         s[i][j] = 0
         gm[i][j] = 0
      }
   }
   //Read Stiffness Matrix
   Dummy = lineRemoved(Dummy)
   for(i = 0; i < nq; i++){
      Dummy1 = nxtLine(Dummy)
      Dummy = lineRemoved(Dummy)
      for(jn = 0; jn < nbw; jn++){
         if (jn < nbw - 1) {
            c = parseFloat(token(Dummy1))
            Dummy1=tknRemoved(Dummy1)
         }else{
            c = parseFloat(Dummy1)
         }
         j = i + jn
         if (j < nq) {
            s[i][j] = c
            s[j][i] = c
         }
      }
   }
   //Read Mass Matrix
   Dummy = lineRemoved(Dummy)
   for(i = 0; i < nq; i++){
      Dummy1 = nxtLine(Dummy)
      Dummy = lineRemoved(Dummy)
      for(jn = 0; jn < nbw; jn++){
         if (jn < nbw - 1) {
            c = parseFloat(token(Dummy1))
            Dummy1=tknRemoved(Dummy1)
         }else{
            c = parseFloat(Dummy1)
         }
         j = i + jn
         if (j < nq) {
            gm[i][j] = c
            gm[j][i] = c
         }
      }
   }
}//InputData

function Cholesky(n) {
   //Cholesky Factorization of Mass Matrix
     //----- L into lower left triangle of a
     for (k = 0; k < n; k++) {
        gm[k][k] = Math.sqrt(gm[k][k])
        for (i = k + 1; i < n; i++) {
           gm[i][k] = gm[i][k] / gm[k][k]
        }
        for (j = k + 1; j < n; j++) {
           for (i = j; i < n; i++) {
              gm[i][j] = gm[i][j] - gm[i][k] * gm[j][k]
           }
        }
     }
}//Cholesky()

function UpdateStiff(n) {
//----- update of stiffness matrix - standard form ax=(lambda)x
     //--- forward substitution I  (invL)*s
     for (j = 0; j < n; j++) {
        s[0][j] = s[0][j] / gm[0][0]
        for (i = 1; i < n; i++) {
           for (k = 0; k < i; k++) {
              s[i][j] = s[i][j] - gm[i][k] * s[k][j]
           }
           s[i][j] = s[i][j] / gm[i][i]
        }
     }
     //--- forward substitution II   (invL)*s*(invL)'
     for (j = 0; j < n; j++) {
        s[j][0] = s[j][0] / gm[0][0]
        for (i = 1; i < n; i++) {
           for (k = 0; k < i; k++) {
              s[j][i] = s[j][i] - gm[i][k] * s[j][k]
           }
           s[j][i] = s[j][i] / gm[i][i]
        }
     }
}UpdateStiff()

function TriDiag(n) {
//----- tri-diagonalize d() diagonal, b() sub-diagonal
//----- s() has the rotation matrix
    for (i = 0; i < n - 2; i++) {
       aa = 0
       for (j = i + 1; j < n; j++) {
          aa = aa + s[j][i] * s[j][i]
       }
       aa = Math.sqrt(aa)
       ww = 2 * aa * (aa + Math.abs(s[i + 1][i]))
       ww = Math.sqrt(ww)
       ia = 1
       if (s[i + 1][i] < 1) {ia = -1}
       //----- diagonal and next to diagonal term
       d[i] = s[i][i]
       b[i] = -ia * aa
       //----- unit vector w() in column i from row i+1 to n
       for (j = i + 1; j < n; j++) {
          s[j][i] = s[j][i] / ww
       }
       s[i + 1][i] = s[i + 1][i] + ia * aa / ww
       //----- w'a in row i from col i+1 to n
       bet = 0
       for (j = i + 1; j < n; j++) {
          s[i][j] = 0
          for (k = i + 1; k < n; k++) {
              s[i][j] = s[i][j] + s[k][i] * s[k][j]
          }
          bet = bet + s[i][j] * s[j][i]
       }
       //----- modified s()
       for (j = i + 1; j < n; j++) {
          for (k = i + 1; k < n; k++) {
             c1 = - 2 * s[j][i] * s[i][k] - 2 * s[i][j] * s[k][i]
             c1 = c1 + 4 * bet * s[k][i] * s[j][i]
             s[j][k] = s[j][k] + c1
          }
       }
    }
    d[n - 2] = s[n - 2][n - 2]
    b[n - 2] = s[n - 2][n - 1]
    d[n - 1] = s[n - 1][n - 1]
    s[n - 2][n - 2] = 1
    s[n - 1][n - 1] = 1
    s[n - 2][n - 1] = 0
    s[n - 1][n - 2] = 0
    //----- now create the q matrix in s()
    for (i = 0; i < n - 2; i++) {
       ii = n - i - 3
       s[ii][ii] = 1
       for (j = 1; j <= i + 2; j++) {
          ij = ii + j
          c1 = 0
          for (k = 1; k <= i + 2; k++) {
             ik = ii + k
             c1 = c1 + s[ik][ij] * s[ik][ii]
          }
          for (k = 1; k <= i + 2; k++) {
             ik = ii + k
             s[ik][ij] = s[ik][ij] - 2 * c1 * s[ik][ii]
          }
       }
       for (j = 1; j <= i + 2; j++) {
          ij = ii + j
          s[ii][ij] = 0
          s[ij][ii] = 0
       }
    }
} TriDiag()

function EigenTD(n) {
     iter = 0
     m = n
  do {
     iter = iter + 1
     dd = 0.5 * (d[m - 2] - d[m - 1])
     bb = b[m - 2] * b[m - 2]
     p = 1
     if ( dd < 1 ) { p = -1 }
     bot = dd + p * Math.sqrt(dd * dd + bb)
     p = d[0] - d[m - 1] + bb / bot
     x = b[0]
     for ( i = 0; i < m - 1; i++ ) {
	pp = Math.sqrt(p * p + x * x)
        cs = -p / pp
        sn = x / pp
        if (i > 0)
           b[i - 1] = cs * b[i - 1] - sn * x
        a1 = d[i]
        a2 = d[i + 1]
        b1 = b[i]
        d[i] = a1 * cs * cs - 2 * b1 * cs * sn + a2 * sn * sn
        b[i] = (a1 - a2) * cs * sn + b1 * (cs * cs - sn * sn)
        d[i + 1] = a1 * sn * sn + 2 * b1 * cs * sn + a2 * cs * cs
        /* ----- update q()  */
        for ( k = 0; k < n; k++) {
           a1 = s[k][i]
           a2 = s[k][i + 1]
           s[k][i] = cs * a1 - sn * a2
           s[k][i + 1] = sn * a1 + cs * a2
        }
        if (i == m - 2) { break }
        x = -b[i + 1] * sn
        b[i + 1] = b[i + 1] * cs
        p = b[i]
     } 
     while (m > 1 && Math.abs(b[m - 2]) < 0.000001){
         m = m - 1
      }
  } while (m > 1)
  m = m - 1
} EigenTD()

function EigenVec(n) {
     /* --- backsubstitution --- */
     for ( j = 0; j < n; j++ ) {
        s[n - 1][j] = s[n - 1][j] / gm[n - 1][n - 1]
        for ( i = n - 2; i >= 0; i--) {
           for ( k = n - 1; k >= i + 1; k-- ) {
              s[i][j] = s[i][j] - gm[k][i] * s[k][j]
           }
           s[i][j] = s[i][j] / gm[i][i]
        }
     }
} //EigenVec()

function AscendEigen(n) {
     /* --- Initialization of nord[] --- */
     for ( i = 0; i < n; i++ ) {
      nord[i] = i
      }
     /* ----- ascending order of eigenvalues */
     for ( i = 0; i < n - 1; i++ ) {
        ii = nord[i]
        i1 = ii
        c1 = d[ii]
        j1 = i
        for ( j = i + 1; j < n; j++) {
           ij = nord[j]
           if (c1 > d[ij]) {
             c1 = d[ij]
             i1 = ij
             j1 = j
           }
        }
        nord[i] = i1
        nord[j1] = ii
     }
}//AscendEigen()

function Output() {
   Dummy = 'Results from Program GENEIGEN\n'
   Dummy = Dummy + title + '\n'
// Eigenvalues and Eigenvectors
  for (i = 0; i < nq; i++) { 
     ii = nord[i]
     iii = i + 1
     Dummy = Dummy + 'Eigenvalue# = ' + iii + '\n'
     omega = Math.sqrt(d[ii])
     freq = 0.5 * omega / Math.PI
     Dummy = Dummy + 'Eigenvalue = ' + d[ii].toExponential(4) + '\n'
     Dummy = Dummy + 'Omega = ' + omega.toExponential(4) + '\n'
     Dummy = Dummy + 'Freq Hz = ' + freq.toExponential(4) + '\n'
     Dummy = Dummy + 'Eigenvector\n'
     for (j = 0; j < nq; j++) {
        Dummy = Dummy + s[j][ii].toExponential(4) + ' '
     }
     Dummy = Dummy + '\n'
  }
document.form.output.value = Dummy
}//Output()





function nxtLine(str){
ii=str.indexOf('\n')
return ltrim(str.substring(0,ii))
}//nxtLine()

function lineRemoved(str){
ii=str.indexOf('\n')
return ltrim(str.substring(ii+1))
}//removed()

function token(str){
ii = str.indexOf(' ')
return str.substring(0,ii)
}

function tknRemoved(str){
ii = str.indexOf(' ')
return ltrim(str.substring(ii+1))
}

function ltrim(str) 
{ 
    return str.replace(/^[ ]+/, ''); 
}//ltrim()




</SCRIPT>
</HEAD>

<BODY BGCOLOR = LightSalmon>
<H2>Generalized Eigenvalue Eigenector Evaluation</H2>
Edit input or cut and paste from a text editor then click SOLVE.
<FORM NAME = form onSubmit = "GenEigen(); return false">
<TEXTAREA NAME=input ROWS=13 COLS=84>
<< EIGENVALUE ANALYIS GENEIGEN >> Next line is problem title 
EXAMPLE 11.5
Num. of DOF    Bandwidth
 8             4 
Banded Stiffness Matrix
 7.068601E+10  157080 -10472  157080 
 3141600 -157080  1570800  0 
 14889.88 -68722.5 -4417.875  88357.5 
 5497800 -88357.5  1178100  0 
 39760.88  265072.5 -35343  353430 
 7068600 -353430  2356200  0 
 7.068603E+10 -353430  0  0 
 4712400  0  0  0 
Banded Mass Matrix
 2.563869E-02  .1084714  8.87493E-03 -6.409672E-02 
 .591662  6.409672E-02 -.4437465  0 
 .2670774  8.436662E-02  1.183324E-02 -.1139497 
 1.99412  .1139497 -1.051844  0 
 .3621584 -.1446285  5.91662E-03 -2.848743E-02 
 1.577765  2.848743E-02 -.1314804  0 
 1.709246E-02 -.0482095  0  0 
 .1753073  0  0  0 
Starting Vector for Inverse Iteration
1 1 1 1 1 1 1 1
</TEXTAREA><BR>
<INPUT TYPE = submit value = 'SOLVE'><BR>
<TEXTAREA NAME=output ROWS=13 COLS=84></TEXTAREA><BR>
</FORM>
(c) T.R.Chandrupatla & A.D.Belegundu
</BODY>
</HTML>
